(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
Tabs = require('bluegg-tabs');
Modal = require('bluegg-modal');

console.log(Tabs)
// Get your Tab elements
var alltabs = document.querySelectorAll('.js-tabs');

// Init the tabs
[].forEach.call(alltabs, function(item, i) {
	new Tabs(alltabs[i]);
});

// find modals
var modals = document.querySelectorAll('.js-modal');

// init on each modal˜˜
[].forEach.call(modals, function(item, i) {
    new Modal(modals[i]);
});

},{"bluegg-modal":2,"bluegg-tabs":3}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * ACCESSIBLE MODAL
 * Principles borrowed from this https://github.com/gdkraus/accessible-modal-dialog
 *
 */

var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]):not([readonly]):not([type=hidden]), select:not([disabled]):not([readonly]):not([type=hidden]), textarea:not([disabled]):not([readonly]):not([type=hidden]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';
var OVERLAY = document.getElementById('modal-overlay');
var PAGE = document.getElementById('global-wrapper');

var lastFocus;
var scrollPos;

var Modal = function () {
	function Modal(modal) {
		_classCallCheck(this, Modal);

		if (!modal) {
			return;
		}

		this.modal = modal;

		this.cancelBtn = this.modal.querySelectorAll('.js-modal-cancel-btn')[0];
		this.closeBtn = this.modal.querySelectorAll('.js-modal-close-btn')[0];
		this.enterBtn = this.modal.querySelectorAll('.js-modal-enter-btn')[0];
		// items which triger this modal need to have a data-attribute ('data-target-name') which matches this.
		this.triggerName = this.modal.getAttribute('data-modal-trigger');
		var triggerSelector = '[data-modal-target="' + this.triggerName + '"]';
		this.triggers = [].slice.call(document.querySelectorAll(triggerSelector));
		this.focusableElements = [].slice.call(this.modal.querySelectorAll(FOCUSABLE_ELEMENTS));
		this.firstItem = this.focusableElements[0];

		this.keys = {
			esc: 27,
			tab: 9,
			enter: 13
		};

		this._init();
	}

	_createClass(Modal, [{
		key: '_init',
		value: function _init() {
			var _this = this;

			// Add listener for all clicks on the targets for the modal
			this.triggers.forEach(function (el) {
				return el.addEventListener('click', function (event) {
					return _this._showModal(_this.modal, event);
				}, false);
			});

			this.closeBtn.addEventListener('click', function () {
				return _this._hideModal(_this.modal);
			}, false);

			if (this.cancelBtn !== undefined) {
				this.cancelBtn.addEventListener('click', function () {
					return _this._cancelBtnEnter(_this.modal, event);
				}, false);
			}

			if (this.enterBtn !== undefined) {
				this.enterBtn.addEventListener('click', function () {
					return _this._cancelButtonModal(_this.modal);
				}, false);
			}

			this.modal.addEventListener('keydown', function (event) {
				return _this._trapTabKey(_this.modal, event);
			}, false);

			this.modal.addEventListener('keydown', function (event) {
				return _this._trapEscapeKey(event);
			}, false);
		}
	}, {
		key: '_trapEscapeKey',
		value: function _trapEscapeKey(evt) {
			// if escape pressed
			if (evt.which == this.keys.esc) {
				// close the modal window
				this.closeBtn.click();
			}
		}
	}, {
		key: '_trapTabKey',
		value: function _trapTabKey(modal, evt) {
			// if tab or shift-tab pressed
			if (evt.which == this.keys.tab) {

				// get list of focusable items (as an array)
				var focusableItems = [].slice.call(modal.querySelectorAll(FOCUSABLE_ELEMENTS));

				// get currently focused item
				var focusedItem = document.activeElement;

				// get the number of focusable items
				var numberOfFocusableItems = focusableItems.length;

				// get the index of the currently focused item
				var focusedItemIndex = focusableItems.indexOf(focusedItem);

				if (evt.shiftKey) {
					//back tab
					// if focused on first item and user preses back-tab, go to the last focusable item
					if (focusedItemIndex == 0) {
						focusableItems[numberOfFocusableItems - 1].focus();
						evt.preventDefault();
					}
				} else {
					//forward tab
					// if focused on the last item and user preses tab, go to the first focusable item
					if (focusedItemIndex == numberOfFocusableItems - 1) {
						focusableItems[0].focus();
						evt.preventDefault();
					}
				}
			}
		}
	}, {
		key: '_setInitialFocus',
		value: function _setInitialFocus() {
			// set focus to first focusable item
			this.firstItem.focus();
		}
	}, {
		key: '_enterButtonModal',
		value: function _enterButtonModal() {
			// BEGIN logic for executing the Enter button action for the modal window
			/* OPTIONAL CODE TO HANDLE FORM SUBMITS ETC GOES HERE */
			// END logic for executing the Enter button action for the modal window
			this._hideModal();
		}
	}, {
		key: '_cancelBtnEnter',
		value: function _cancelBtnEnter(modal, evt) {
			if (evt.which === this.keys.enter || evt.type === 'click') {
				evt.preventDefault();
				this._hideModal(modal);
			}
		}
	}, {
		key: '_showModal',
		value: function _showModal(modal, evt) {

			scrollPos = window.pageYOffset || document.documentElement.scrollTop;

			if (evt.which === this.keys.enter || evt.type === 'click') {

				evt.preventDefault();

				// save scrollPos
				document.documentElement.classList.add('modal-is-open');
				PAGE.setAttribute('aria-hidden', 'true'); // mark the main page as hidden
				modal.setAttribute('aria-hidden', 'false'); // mark the modal window as visible
				OVERLAY.classList.add('is-active'); // insert an overlay to prevent clicking and make a visual change to indicate the main apge is not available
				modal.classList.add('is-active'); // make the modal window visible
				// save current focus
				lastFocus = document.activeElement;

				this._setInitialFocus();
			}
		}
	}, {
		key: '_hideModal',
		value: function _hideModal(modal) {
			OVERLAY.classList.remove('is-active'); // remove the overlay in order to make the main screen available again
			modal.classList.remove('is-active'); // hide the modal window
			modal.setAttribute('aria-hidden', 'true'); // mark the modal window as hidden
			PAGE.setAttribute('aria-hidden', 'false'); // mark the main page as visible
			document.documentElement.classList.remove('modal-is-open');
			// set focus back to element that had it before the modal was opened
			lastFocus.focus();
			document.documentElement.scrollTop = document.body.scrollTop = scrollPos;
		}
	}]);

	return Modal;
}();

exports.default = Modal;
module.exports = exports['default'];


},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tabs
 * * * * * * * * * * * * * * * * * * * * *
 */

var Tabs = function () {
	function Tabs(el, selectedIndex) {
		_classCallCheck(this, Tabs);

		if (!el) {
			return;
		}

		this.el = el;
		this.tabTriggers = this.el.getElementsByClassName('js-tab-trigger');
		this.tabPanels = this.el.getElementsByClassName('js-tab-panel');

		if (this.tabTriggers.length === 0 || this.tabTriggers.length !== this.tabPanels.length) {
			return;
		}

		this._init(selectedIndex);
	}

	_createClass(Tabs, [{
		key: '_init',
		value: function _init(selectedIndex) {

			this.tabTriggersLength = this.tabTriggers.length;
			this.selectedTab = 0;
			this.prevSelectedTab = null;
			this.clickListener = this._clickEvent.bind(this);
			this.keydownListener = this._keydownEvent.bind(this);
			this.keys = {
				prev: 37,
				next: 39
			};

			for (var i = 0; i < this.tabTriggersLength; i++) {
				this.tabTriggers[i].index = i;
				this.tabTriggers[i].addEventListener('click', this.clickListener, false);
				this.tabTriggers[i].addEventListener('keydown', this.keydownListener, false);

				if (this.tabTriggers[i].classList.contains('is-selected')) {
					this.selectedTab = i;
				}
			}

			if (!isNaN(selectedIndex)) {
				this.selectedTab = selectedIndex < this.tabTriggersLength ? selectedIndex : this.tabTriggersLength - 1;
			}

			this.selectTab(this.selectedTab);
			this.el.classList.add('is-initialized');
		}
	}, {
		key: '_clickEvent',
		value: function _clickEvent(e) {

			e.preventDefault();

			if (e.target.index === this.selectedTab) {
				return;
			}

			this.selectTab(e.target.index, true);
		}
	}, {
		key: '_keydownEvent',
		value: function _keydownEvent(e) {

			var targetIndex;

			if (e.keyCode === this.keys.prev || e.keyCode === this.keys.next) {
				e.preventDefault();
			} else {
				return;
			}

			if (e.keyCode === this.keys.prev && e.target.index > 0) {
				targetIndex = e.target.index - 1;
			} else if (e.keyCode === this.keys.next && e.target.index < this.tabTriggersLength - 1) {
				targetIndex = e.target.index + 1;
			} else {
				return;
			}

			this.selectTab(targetIndex, true);
		}
	}, {
		key: '_show',
		value: function _show(index, userInvoked) {

			this.tabTriggers[index].classList.add('is-selected');
			this.tabTriggers[index].setAttribute('aria-selected', true);
			this.tabTriggers[index].setAttribute('tabindex', 0);

			this.tabPanels[index].classList.remove('is-hidden');
			this.tabPanels[index].setAttribute('aria-hidden', false);
			this.tabPanels[index].setAttribute('tabindex', 0);

			if (userInvoked) {
				this.tabTriggers[index].focus();
			}
		}
	}, {
		key: '_hide',
		value: function _hide(index) {

			this.tabTriggers[index].classList.remove('is-selected');
			this.tabTriggers[index].setAttribute('aria-selected', false);
			this.tabTriggers[index].setAttribute('tabindex', -1);

			this.tabPanels[index].classList.add('is-hidden');
			this.tabPanels[index].setAttribute('aria-hidden', true);
			this.tabPanels[index].setAttribute('tabindex', -1);
		}
	}, {
		key: 'selectTab',
		value: function selectTab(index, userInvoked) {

			if (this.prevSelectedTab === null) {
				for (var i = 0; i < this.tabTriggersLength; i++) {
					if (i !== index) {
						this._hide(i);
					}
				}
			} else {
				this._hide(this.selectedTab);
			}

			this.prevSelectedTab = this.selectedTab;
			this.selectedTab = index;

			this._show(this.selectedTab, userInvoked);
		}
	}, {
		key: 'destroy',
		value: function destroy() {

			for (var i = 0; i < this.tabTriggersLength; i++) {
				this.tabTriggers[i].classList.remove('is-selected');
				this.tabTriggers[i].removeAttribute('aria-selected');
				this.tabTriggers[i].removeAttribute('tabindex');

				this.tabPanels[i].classList.remove('is-hidden');
				this.tabPanels[i].removeAttribute('aria-hidden');
				this.tabPanels[i].removeAttribute('tabindex');

				this.tabTriggers[i].removeEventListener('click', this.clickListener, false);
				this.tabTriggers[i].removeEventListener('keydown', this.keydownListener, false);

				delete this.tabTriggers[i].index;
			}

			this.el.classList.remove('is-initialized');
		}
	}]);

	return Tabs;
}();

exports.default = Tabs;
module.exports = exports['default'];


},{}]},{},[1]);
